import type { Config } from './types'
import { existsSync, mkdirSync, readdirSync, writeFileSync } from 'node:fs'
import { dirname, resolve } from 'node:path'
import process from 'node:process'
import { Logger } from '@stacksjs/clarity'
import { deepMerge } from './utils'

const log = new Logger('bunfig', {
  showTags: true,
})

type ConfigNames = string

export async function config<T>(
  nameOrOptions: ConfigNames | Config<T> = { defaultConfig: {} as T },
): Promise<T> {
  if (typeof nameOrOptions === 'string') {
    const { cwd } = await import('node:process')

    return await loadConfig({
      name: nameOrOptions,
      cwd: cwd(),
      generatedDir: './generated',
      configDir: './config',
      defaultConfig: {} as T,
    })
  }

  return await loadConfig(nameOrOptions)
}

/**
 * Attempts to load a config file from a specific path
 */
export async function tryLoadConfig<T>(configPath: string, defaultConfig: T): Promise<T | null> {
  if (!existsSync(configPath))
    return null

  try {
    const importedConfig = await import(configPath)
    const loadedConfig = importedConfig.default || importedConfig

    // Return null if the loaded config is not a valid object
    if (typeof loadedConfig !== 'object' || loadedConfig === null || Array.isArray(loadedConfig))
      return null

    // Validate that the loaded config can be merged with the default config
    try {
      return deepMerge(defaultConfig, loadedConfig) as T
    }
    catch {
      return null
    }
  }
  catch {
    return null
  }
}

/**
 * Load Config
 *
 * @param {object} options - The configuration options.
 * @param {string} options.name - The name of the configuration file.
 * @param {string} [options.cwd] - The current working directory.
 * @param {T} options.defaultConfig - The default configuration.
 * @returns {Promise<T>} The merged configuration.
 * @example ```ts
 * await loadConfig({
 *   name: 'example',
 *   defaultConfig: { foo: 'bar' }
 * })
 * ```
 */
export async function loadConfig<T>({
  name = '',
  cwd,
  defaultConfig,
  verbose = false,
}: Config<T>): Promise<T> {
  // Server environment: load the config from the file system
  const baseDir = cwd || process.cwd()
  const extensions = ['.ts', '.js', '.mjs', '.cjs', '.json']

  if (verbose) {
    log.info(`Loading configuration for "${name}" from ${baseDir}`)
  }

  // Try loading config in order of preference
  const configPaths = [
    `${name}.config`,
    `.${name}.config`,
    name,
    `.${name}`,
  ]

  for (const configPath of configPaths) {
    for (const ext of extensions) {
      const fullPath = resolve(baseDir, `${configPath}${ext}`)
      const config = await tryLoadConfig(fullPath, defaultConfig)
      if (config !== null) {
        if (verbose) {
          log.success(`Configuration loaded from: ${configPath}${ext}`)
        }
        return config
      }
    }
  }

  // Then try package.json
  try {
    const pkgPath = resolve(baseDir, 'package.json')
    if (existsSync(pkgPath)) {
      const pkg = await import(pkgPath)
      const pkgConfig = pkg[name]

      if (pkgConfig && typeof pkgConfig === 'object' && !Array.isArray(pkgConfig)) {
        try {
          if (verbose) {
            log.success(`Configuration loaded from package.json: ${name}`)
          }
          return deepMerge(defaultConfig, pkgConfig) as T
        }
        catch (error) {
          if (verbose) {
            log.warn(`Failed to merge package.json config for ${name}:`, error)
          }
          // If merging fails, continue to default config
        }
      }
    }
  }
  catch (error) {
    if (verbose) {
      log.warn(`Failed to load package.json for ${name}:`, error)
    }
    // If package.json loading fails, continue to default config
  }

  if (verbose) {
    log.info(`No configuration found for ${name}, using default configuration`)
  }
  return defaultConfig
}

export const defaultConfigDir: string = resolve(
  process.cwd(),
  'config',
)

export const defaultGeneratedDir: string = resolve(
  process.cwd(),
  'src/generated',
)

export function generateConfigTypes(options: {
  configDir: string
  generatedDir: string
}): void {
  const configDir = resolve(process.cwd(), options.configDir)
  const generatedDir = resolve(process.cwd(), options.generatedDir)
  const outputFile = resolve(generatedDir, 'config-types.ts')

  // Create generated directory if it doesn't exist
  if (!existsSync(dirname(outputFile)))
    mkdirSync(dirname(outputFile), { recursive: true, mode: 0o777 })

  // Default to empty array if config dir doesn't exist
  const files = existsSync(configDir)
    ? readdirSync(configDir)
        .map(file => file.replace(/\.(ts|js|mjs|cjs|mts|cts|json)$/, ''))
        .sort() // Sort the file names alphabetically
    : []

  const content = `// Generated by bunfig
export type ConfigNames = ${files.length ? `'${files.join('\' | \'')}'` : 'string'}
`

  writeFileSync(outputFile, content, { mode: 0o666 })
}
